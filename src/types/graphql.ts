/* IMP NOTE: This file is auto-generated by npm run gql:codegen, don't change manually */
export type Maybe<T> = T | undefined
export type InputMaybe<T> = T | undefined
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] }
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> }
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> }
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never }
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never }
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string, output: string },
  String: { input: string, output: string },
  Boolean: { input: boolean, output: boolean },
  Int: { input: number, output: number },
  Float: { input: number, output: number },
  /**  https://the-guild.dev/graphql/scalars/docs/usage   */
  BigInt: { input: number, output: number },
  /**  2007-12-03  */
  Date: { input: string, output: string },
  /**  2007-12-03T10:15:30Z  */
  DateTime: { input: string, output: string },
  EmailAddress: { input: string, output: string },
  JWT: { input: string, output: string },
  NonEmptyString: { input: string, output: string },
  PhoneNumber: { input: string, output: string },
  URL: { input: string, output: string },
  Void: { input: void, output: void },
}

export type Code = Node & {
  /**  The OTP code that was sent to the user  */
  code: Scalars['NonEmptyString']['output'],
  createdAt: Scalars['DateTime']['output'],
  /**  When the code expires if set  */
  expireAt?: Maybe<Scalars['DateTime']['output']>,
  id: Scalars['ID']['output'],
  updatedAt: Scalars['DateTime']['output'],
  /**  The user that this code is for  */
  userId: Scalars['ID']['output'],
}

/**  Error codes  */
export enum ErrorCode {
  BAD_USER_INPUT = 'BAD_USER_INPUT',
  CONFLICT = 'CONFLICT',
  DATABASE_ERROR = 'DATABASE_ERROR',
  FORBIDDEN = 'FORBIDDEN',
  GRAPHQL_PARSE_FAILED = 'GRAPHQL_PARSE_FAILED',
  GRAPHQL_VALIDATION_FAILED = 'GRAPHQL_VALIDATION_FAILED',
  INTERNAL_SERVER_ERROR = 'INTERNAL_SERVER_ERROR',
  LOCKED = 'LOCKED',
  METHOD_NOT_ALLOWED = 'METHOD_NOT_ALLOWED',
  NOT_FOUND = 'NOT_FOUND',
  TOO_MANY_REQUESTS = 'TOO_MANY_REQUESTS',
  UNAUTHENTICATED = 'UNAUTHENTICATED'
}

export type Mutation = {
  resendCode: SuccessPayload,
  signIn: User,
  signUp: User,
  verifyCode: User,
}


export type MutationResendCodeArgs = {
  input: ResendCodeInput,
}


export type MutationSignInArgs = {
  input: SignInInput,
}


export type MutationSignUpArgs = {
  input: SignUpInput,
}


export type MutationVerifyCodeArgs = {
  input: VerifyCodeInput,
}

export type Node = {
  createdAt: Scalars['DateTime']['output'],
  id: Scalars['ID']['output'],
  updatedAt: Scalars['DateTime']['output'],
}

export type PageInfo = {
  endCursor?: Maybe<Scalars['String']['output']>,
  hasNextPage: Scalars['Boolean']['output'],
  hasPreviousPage: Scalars['Boolean']['output'],
  startCursor?: Maybe<Scalars['String']['output']>,
}

export type PageInput = {
  /**  Cursor-based pagination, load after this cursor  */
  after?: InputMaybe<Scalars['String']['input']>,
  /**  How many to load (from the start), supports 0 for getting the `total`  */
  first?: InputMaybe<Scalars['Int']['input']>,
  /**  How many to load (from the end, reversed results)  */
  last?: InputMaybe<Scalars['Int']['input']>,
  /**  Offset-based pagination, skip this many  */
  offset?: InputMaybe<Scalars['Int']['input']>,
}

export type Query = {
  add?: Maybe<Scalars['Int']['output']>,
  me?: Maybe<User>,
}


export type QueryAddArgs = {
  x?: InputMaybe<Scalars['Int']['input']>,
  y?: InputMaybe<Scalars['Int']['input']>,
}

export type ResendCodeInput = {
  mobile?: InputMaybe<Scalars['PhoneNumber']['input']>,
  userId?: InputMaybe<Scalars['ID']['input']>,
}

export type SignInInput = {
  mobile: Scalars['PhoneNumber']['input'],
  password: Scalars['NonEmptyString']['input'],
}

export type SignUpInput = {
  firstName: Scalars['NonEmptyString']['input'],
  lastName?: InputMaybe<Scalars['NonEmptyString']['input']>,
  mobile: Scalars['PhoneNumber']['input'],
  password: Scalars['NonEmptyString']['input'],
}

export type SuccessPayload = {
  error?: Maybe<ErrorCode>,
}

export type User = Node & {
  codes: Array<Code>,
  createdAt: Scalars['DateTime']['output'],
  firstName: Scalars['NonEmptyString']['output'],
  id: Scalars['ID']['output'],
  isBlocked: Scalars['Boolean']['output'],
  isVerified: Scalars['Boolean']['output'],
  lastName?: Maybe<Scalars['NonEmptyString']['output']>,
  mobile: Scalars['PhoneNumber']['output'],
  /**  The generated full (first+last) name  */
  name: Scalars['NonEmptyString']['output'],
  password: Scalars['NonEmptyString']['output'],
  salt: Scalars['NonEmptyString']['output'],
  status: UserStatus,
  /**  A fresh JWT for the user  */
  token: Scalars['JWT']['output'],
  updatedAt: Scalars['DateTime']['output'],
}

export enum UserStatus {
  Superadmin = 'Superadmin',
  User = 'User'
}

export type VerifyCodeInput = {
  code: Scalars['NonEmptyString']['input'],
  mobile?: InputMaybe<Scalars['PhoneNumber']['input']>,
  userId?: InputMaybe<Scalars['ID']['input']>,
}
